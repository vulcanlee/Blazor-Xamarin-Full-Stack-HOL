@using Blogger.Models
@using System.Linq
@using Microsoft.EntityFrameworkCore
@inject BlogDbContext BlogDbContext
<h3>部落格文章</h3>

@if (ShowEditRecord)
{
    <div class="my-2">
        <div class="card">
            <div class="card-header">
                Featured
            </div>
            <div class="card-body">
                <EditForm Model="@CurrentBlogPost" OnValidSubmit="@HandleValidSubmitAsync">
                    <DataAnnotationsValidator />
                    <ValidationSummary />
                    <div class="form-group">
                        <label for="taskName">文章主題</label>
                        <InputText id="name" class="form-control" @bind-Value="@CurrentBlogPost.Title" />
                    </div>
                    <div class="form-group">
                        <label for="taskName">文章內容</label>
                        <InputText id="name" class="form-control" @bind-Value="@CurrentBlogPost.Text" />
                    </div>
                    <div class="row">
                        <button type="submit" class="btn btn-primary col mr-3">儲存</button>
                        <button class="btn btn-secondary col ml-3"
                                @onclick="OnCalcelEditRecord">取消</button>
                    </div>
                </EditForm>
            </div>
        </div>
    </div>
}
<div class="my-3">
    @*透過 Blazor 的資料綁定，將新增按鈕的點選事件，綁定到 C# 的委派處理方法*@
    <input type="button" class="btn btn-primary" @onclick="OnAdd" value="新增" />
</div>
<table class="table">
    <thead>
        <tr>
            <th>文章</th>
            <th>修改</th>
            <th>刪除</th>
        </tr>
    </thead>
    <tbody>
        @*列出集合清單中的每一筆紀錄到 HTML Table 內*@
        @foreach (var postItem in BlogPosts)
        {
            <tr>
                @*透過資料綁定，把集合清單內的紀錄屬性，顯示在網頁上*@
                <td>@postItem.Title</td>
                <td>
                    @*透過 Blazor 的資料綁定，將修改按鈕的點選事件，綁定到 C# 的委派處理方法*@
                    @*當該修改按鈕點選事件被觸發的時候，將會把現在顯示的紀錄物件傳送過去*@
                    <input type="button" class="btn btn-primary" value="修改"
                           @onclick="()=>OnEdit(postItem)" />
                </td>
                <td>
                    @*透過 Blazor 的資料綁定，將刪除按鈕的點選事件，綁定到 C# 的委派處理方法*@
                    <input type="button" class="btn btn-danger" value="刪除"
                           @onclick="async ()=>await OnDeleteAsync(postItem)" />
                </td>
            </tr>
        }
    </tbody>
</table>

@code {
    public List<BlogPost> BlogPosts { get; set; } = new List<BlogPost>();
    public BlogPost CurrentBlogPost { get; set; } = new BlogPost();
    public bool ShowEditRecord { get; set; } = false;
    public bool IsAddRecord { get; set; } = false;

    protected override async Task OnInitializedAsync()
    {
        await Reload();
    }

    async Task Reload()
    {
        BlogPosts = await BlogDbContext.BlogPost
        .ToListAsync();
    }

    void OnAdd()
    {
        CurrentBlogPost = new BlogPost();
        IsAddRecord = true;
        ShowEditRecord = true;
    }

    void OnEdit(BlogPost postItem)
    {
        CurrentBlogPost = postItem;
        IsAddRecord = false;
        ShowEditRecord = true;
    }

    void OnCalcelEditRecord()
    {
        ShowEditRecord = false;
    }

    async Task OnDeleteAsync(BlogPost postItem)
    {
        BlogDbContext.BlogPost
            .Remove(postItem);
        await BlogDbContext.SaveChangesAsync();
        await Reload();
        return;
    }
    async Task HandleValidSubmitAsync()
    {
        if(IsAddRecord == true)
        {
            await BlogDbContext.BlogPost
                .AddAsync(CurrentBlogPost);
            await BlogDbContext.SaveChangesAsync();
            await Reload();
        }
        else
        {
            BlogDbContext.BlogPost.Update(CurrentBlogPost);
            await BlogDbContext.SaveChangesAsync();
            await Reload();
        }
        ShowEditRecord = false;
    }
}
